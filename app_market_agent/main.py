import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os
import logging
from datetime import datetime
from dotenv import load_dotenv

# Import local modules
from store_scraper import StoreScraper
from ai_analyzer import AIAnalyzer
from database import SessionLocal, engine
import models

load_dotenv()
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class AppMarketAgent:
    def __init__(self):
        self.store_scraper = StoreScraper()
        self.ai_analyzer = AIAnalyzer()
        
        self.smtp_server = os.getenv("SMTP_SERVER", "smtp.gmail.com")
        self.smtp_port = int(os.getenv("SMTP_PORT", 587))
        self.sender_email = os.getenv("SENDER_EMAIL")
        self.sender_password = os.getenv("SENDER_PASSWORD")
        self.recipient_email = "handrake99@gmail.com"

    def generate_report_content(self, store_results: list) -> str:
        report = f"## ðŸ“ˆ ì¼ì¼ ìœ ë§ ì•± ë§ˆì¼“ ë¶„ì„ ë¦¬í¬íŠ¸ ({datetime.now().strftime('%Y-%m-%d')})\n\n"
        report += "ë³¸ ë¦¬í¬íŠ¸ëŠ” ë‹ˆì¹˜ ë§ˆì¼“, ìˆ˜ìµ ëª¨ë¸, 1ì¸ ê°œë°œ ê°€ëŠ¥ì„±ì„ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ë§ëœ ìž ìž¬ë ¥ ë†’ì€ ì¸ë”” iOS ì•± ëª©ë¡ìž…ë‹ˆë‹¤.\n\n"
        
        report += "### ðŸ† ì—„ì„ ëœ ìœ ë§ íƒ€ê²Ÿ ì•±\n"
        if not store_results:
            report += "ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì•±ì´ ì—†ìŠµë‹ˆë‹¤.\n\n"
        else:
            for i, result in enumerate(store_results, 1):
                app = result['app_metadata']
                eval_reason = result['evaluation_reason']
                report += f"{i}. **{app.get('title')}** (iOS)\n"
                report += f"   - URL: {app.get('url', 'N/A')}\n"
                report += f"   - ì¶œì²˜(ê²€ìƒ‰ í‚¤ì›Œë“œ): {app.get('source_keyword', 'Unknown')}\n"
                report += f"   - ì„¤ëª… ìš”ì•½: {app.get('description', '').replace(chr(10), ' ')[:150]}...\n"
                report += f"   - **ì„ ì • ì‚¬ìœ  (LLM í‰ê°€):**\n"
                report += f"     - ë‹ˆì¹˜ ë§ˆì¼“: {eval_reason.get('niche_market', {}).get('reason', '')}\n"
                report += f"     - ìˆ˜ìµ ëª¨ë¸: {eval_reason.get('revenue_model', {}).get('reason', '')}\n"
                report += f"     - ê¸°ëŠ¥ ë‹¨ìˆœì„±: {eval_reason.get('simplicity', {}).get('reason', '')}\n\n"
            
        report += "\n---\n*Generated by App Market Analyzer AI Agent*"
        return report

    def send_email_report(self, markdown_content: str):
        if not all([self.sender_email, self.sender_password]):
            logging.error("Email credentials not fully configured. Storing report to file instead.")
            with open("daily_report.md", "w") as f:
                f.write(markdown_content)
            logging.info("Report saved to daily_report.md")
            return

        msg = MIMEMultipart()
        msg['From'] = self.sender_email
        msg['To'] = self.recipient_email
        msg['Subject'] = f"[App Market Analyzer] ì¼ì¼ ë¶„ì„ ë¦¬í¬íŠ¸ - {datetime.now().strftime('%Y-%m-%d')}"

        # You'd normally want to convert markdown to HTML here for better email formatting
        # For simplicity, we send it as plain text markdown
        msg.attach(MIMEText(markdown_content, 'plain'))

        try:
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.sender_email, self.sender_password)
            server.send_message(msg)
            server.quit()
            logging.info(f"Successfully sent email report to {self.recipient_email}")
        except Exception as e:
            logging.error(f"Failed to send email: {e}")
            with open("daily_report.md", "w") as f:
                f.write(markdown_content)

    def run(self):
        import io
        log_capture_string = io.StringIO()
        ch = logging.StreamHandler(log_capture_string)
        ch.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        ch.setFormatter(formatter)
        
        root_logger = logging.getLogger()
        root_logger.addHandler(ch)

        try:
            logging.info("Starting Daily App Market Analysis Cycle...")
            
            target_store_apps = self.store_scraper.get_top_target_apps(max_pool_size=40)
            store_analysis_results = []
            
            models.Base.metadata.create_all(bind=engine)
            db = SessionLocal()
            run_record = models.RunHistory()
            db.add(run_record)
            
            try:
                db.commit()
                db.refresh(run_record)
            except Exception as e:
                logging.error(f"Failed to create RunHistory in DB: {e}")
                db.rollback()
                return
                
            try:
                for app in target_store_apps:
                    if len(store_analysis_results) >= 15:
                        break
                        
                    evaluation = self.ai_analyzer.evaluate_app_potential(app)
                    if not evaluation.get("is_approved", False):
                        logging.info(f"App {app.get('title')} rejected by LLM filter: {evaluation}")
                        continue
                    
                    logging.info(f"App {app.get('title')} approved by LLM filter!")
                    
                    app_item = models.AppItem(
                        run_history_id=run_record.id,
                        platform=app.get('platform', 'ios'),
                        app_store_id=app.get('app_id', ''),
                        title=app.get('title', ''),
                        description=app.get('description', ''),
                        price=app.get('price', ''),
                        url=app.get('url', ''),
                        source_keyword=app.get('source_keyword', ''),
                        eval_niche_market=evaluation.get('niche_market', {}).get('reason', ''),
                        eval_revenue_model=evaluation.get('revenue_model', {}).get('reason', ''),
                        eval_simplicity=evaluation.get('simplicity', {}).get('reason', '')
                    )
                    db.add(app_item)
                    
                    store_analysis_results.append({
                        'app_metadata': app,
                        'evaluation_reason': evaluation
                    })
                    
                run_record.total_apps_found = len(store_analysis_results)
                run_record.log_output = log_capture_string.getvalue()
                db.commit()
                     
            except Exception as e:
                db.rollback()
                if "token/quota limits" in str(e):
                    logging.error("ðŸš¨ CRITICAL: LLM Token/Quota Limit Exceeded. Halting execution immediately. No email will be sent.")
                    return
                else:
                    logging.error(f"Unexpected error during analysis loop: {e}")
            finally:
                db.close()

            report = self.generate_report_content(store_analysis_results)
            self.send_email_report(report)
            logging.info("Daily cycle completed.")
            
        finally:
            if 'run_record' in locals():
                try:
                    db2 = SessionLocal()
                    db2.query(models.RunHistory).filter(models.RunHistory.id == run_record.id).update(
                        {"log_output": log_capture_string.getvalue()}
                    )
                    db2.commit()
                    db2.close()
                except Exception:
                    pass
            
            root_logger.removeHandler(ch)
            log_capture_string.close()

if __name__ == "__main__":
    agent = AppMarketAgent()
    agent.run()
